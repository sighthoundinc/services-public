#!/bin/bash
set -e
SCRIPT_PATH="$(
    cd -- "$(dirname "$0")" >/dev/null 2>&1
    pwd -P
)"
export SCRIPT_PATH
SH_BASE="$(realpath "${SCRIPT_PATH}"/../..)"
export SH_BASE
SERVICES_PATH="$(realpath "${SCRIPT_PATH}"/../services)"
export SERVICES_PATH
EXAMPLES_PATH="$(realpath "${SCRIPT_PATH}"/../examples)"
export EXAMPLES_PATH
DEPLOYMENT_EXAMPLES_PATH="$(realpath "${SCRIPT_PATH}"/../deployment-examples)"
export DEPLOYMENT_EXAMPLES_PATH
MEDIA_PATH="${SH_BASE}"/media
export MEDIA_PATH
DB_PATH="${SH_BASE}"/db
export DB_PATH
LOGS_PATH="${SH_BASE}"/logs
export LOGS_PATH
LICENSE_PATH="${SH_BASE}"/license
export LICENSE_PATH

# Check if curl is installed
if ! command -v curl &> /dev/null; then
    echo "curl is not installed. Please install curl and try again."
    exit 1
fi

if command -v docker-compose &>/dev/null && docker-compose version >/dev/null 2>&1; then
    # Use `docker-compose`
    DOCKER_COMPOSE="docker-compose"
elif command -v docker &>/dev/null && docker compose version >/dev/null 2>&1; then
    DOCKER_COMPOSE="docker compose"
else
    echo "Neither docker-compose nor docker compose are available. Please install one of them and try again."
    exit 1
fi

test_rtsp_stream() {
    local rtsp_url="$1"
    local timeout_seconds="$2"

    local status_code=$(docker run --entrypoint=/usr/local/bin/ffprobe --network=host linuxserver/ffmpeg -v quiet -select_streams v:0 -show_entries stream=codec_name -of default=nokey=1:noprint_wrappers=1 -rtsp_transport tcp "$rtsp_url" -timeout "$timeout_seconds" 2>/dev/null)

    if [[ -n $status_code ]]; then
        echo "RTSP stream $rtsp_url is up"
        return 0
    else
        echo "ERROR: RTSP stream $rtsp_url is down"
        return 1
    fi
}

check_rabbitmq() {
    echo "RabbitMQ exchanges:"
    curl -s -u guest:guest http://localhost:15672/api/exchanges | tr ',' '\n' | tac | grep -E '"name"|publish_in_details|publish_out_details' | sed 's/"name":/- Exchange: /' | sed 's/"publish_in_details":/   Publish in: /' | sed 's/"publish_out_details":/   Publish out: /'
    echo "RabbitMQ queues:"
    curl -s -u guest:guest http://localhost:15672/api/queues | tr ',' '\n' | tac | grep -E '"name"|message_bytes_.*' | sed 's/"name":/- Queue: /'
}

check_endpoint() {
    curl --connect-timeout 2 --output /dev/null --silent --head $@ "$1"
}

check_service_up() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    local container_ids
    local container_id
    local state

    # Get container IDs
    container_ids=$(${DOCKER_COMPOSE} -f "${service_full_path}/docker-compose.yml" ps -a -q)

    # Check if there are no containers
    if [ -z "$container_ids" ]; then
        echo "No ${service} containers are found"
        return 1
    fi

    # Loop through each container ID
    for container_id in $container_ids; do
        # Get the state of the container
        state=$(docker inspect --format='{{.State.Status}}' "$container_id")

        # Check if the state is not 'running'
        if [ "$state" != "running" ]; then
            echo "Container '$container_id; from ${service} is not up"
            return 1
        fi
    done

    # If the function reaches this point, all containers are running
    echo "All ${service} containers are up"
    return 0
}

# Merge the services
# First file has the highest priority
# This function merges multiple environment files into a single output file
# The first argument is the output file name, and the rest are the input files
function merge_env_files() {
    output_file=$1
    shift 1
    env_files=$*

    echo "Merging ${env_files} into '${output_file}'"


    # Sort the input files and remove duplicates, then write the result to the output file
    set -e
    sort -u -t '=' -k 1,1 "$@" > "$output_file.tmp"
    set +e

    # Remove comments from the output file
    sed -i.bkp -e '/^[ \t]*#/d' "$output_file.tmp"
    rm "$output_file.tmp.bkp"

        # Write a header to the output file
    cat <<EOF >"$output_file"
# This file is autogenerated by the sh-services script
# Do not modify this file manually or your changes will be lost
# If you intend to modify the configuration of your service go to: https://github.com/sighthoundinc/services/blob/public/README.md#changing-docker-env-variables
EOF

    # Append the contents of the output file to the output file
    cat "$output_file.tmp" >> "$output_file"
    rm "$output_file.tmp"

    echo ""
    echo "Auto-generated file '${output_file}' contains:"
    echo
    cat "$1"
    echo ""
}

function remove_orphans() {
    containers=$(docker ps -a -q)
    for container in $containers; do
        container_name=$(docker inspect -f '{{.Name}}' "${container}")
        working_dir=$(docker inspect -f '{{(index .Config.Labels "com.docker.compose.project.working_dir")}}' "${container}")
        if [[ "${working_dir}" == "${SH_BASE}"* ]]; then
            echo "Found container ${container_name} with working dir: '${working_dir}'"
            # If the working dir does not exist anymore and starts with 'SERVICES_PATH', then remove the container
            if [[ ! -d "${working_dir}" ]]; then
                echo "Removing orphan container: ${container_name} ${container}"
                docker rm -f "${container}"
            fi
        fi

    done
}

function clean_logs() {
    mkdir -p ${LOGS_PATH}
    find "${LOGS_PATH:?}" -type f -exec truncate -s 0 {} \;
    echo "Removed all log files"
}

function clean_media() {
    echo "Cleaning media files"
    mkdir -p ${MEDIA_PATH} ${DB_PATH}
    du -sh "${MEDIA_PATH:?}"
    # Remove all media files
    find "${MEDIA_PATH:?}" -type f -exec rm -f {} \;
    # Remove all timestamp subfolders as well
    find "${MEDIA_PATH:?}" -mindepth 4 -type d -exec rm -rf {} +
    # Remove all db files
    find "${DB_PATH:?}" -type f -exec rm -f {} \;
    # After removing db, restart mcp if it is running
    if [ "$(status mcp)" = "up" ]; then
        restart mcp
    fi
    echo "Removed all media files"
    du -sh "${MEDIA_PATH:?}"
}

function clean_rabbitmq() {
    down rabbitmq
    # Remove Docker volume if it exists
    if docker volume ls | grep -q "rabbitmq_rabbitmq_persistent_storage"; then
        echo "Removing rabbitmq_rabbitmq_persistent_storage volume"
        docker volume rm rabbitmq_rabbitmq_persistent_storage
    fi
    up rabbitmq
}

function save_defaults_info() {
    if [ ! -d "${SERVICES_PATH}"/conf ]; then
        mkdir -p "${SERVICES_PATH}"/conf
    fi
    cat <<EOF >"${SERVICES_PATH}"/conf/0020-services.env
# This file is autogenerated by the sh-services script
# Do not modify this file manually

SH_BASE=${SH_BASE}
SH_SERVICES_PATH=${SERVICES_PATH}
MEDIA_PATH=${MEDIA_PATH}
DB_PATH=${DB_PATH}
LOGS_PATH=${LOGS_PATH}
LICENSE_PATH=${LICENSE_PATH}
EOF
}

function get_l4t_version() {
    L4TBASE_VERSION=32.7.3
    if command -v bai-osinfo &>/dev/null; then
        L4TBASE_VERSION=$(bai-osinfo -l)
        [[ "$L4TBASE_VERSION" == 32.7.* ]] && L4TBASE_VERSION=32.7.3
        [[ "$L4TBASE_VERSION" == 35.*.* ]] && L4TBASE_VERSION=35.3.1
    fi
    echo "$L4TBASE_VERSION"
}

function save_arch_info() {
    if [ ! -d "${SERVICES_PATH}"/conf ]; then
        mkdir -p "${SERVICES_PATH}"/conf
    fi
    cat <<EOF >"${SERVICES_PATH}"/conf/0010-arch.env
# This file is autogenerated by the sh-services script
# Do not modify this file manually

EOF
    if [ "$(uname -m)" == "x86_64" ]; then
        echo "SH_ARCH=-amd64" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_NODE=false" >>"${SERVICES_PATH}"/conf/0010-arch.env
    elif [ "$(uname -m)" == "aarch64" ]; then
        L4TBASE_VERSION=$(get_l4t_version)
        if command -v bai-osinfo &>/dev/null; then
            SH_MACHINE=$(bai-osinfo -m)
            SH_SERIAL=$(bai-osinfo -s)
            if [[ $SH_MACHINE == *"node"* ]]; then
                SH_NODE=true
            else
                SH_NODE=false
            fi
        fi

        echo "SH_ARCH=-r${L4TBASE_VERSION}-arm64v8" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_MACHINE=${SH_MACHINE}" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_NODE=${SH_NODE}" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_SERIAL=${SH_SERIAL}" >>"${SERVICES_PATH}"/conf/0010-arch.env
    else
        echo "Unknown architecture: $(uname -m)"
        exit 1
    fi
}

function merge() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    touch "${service_full_path}/.env"
    env_files_to_merge=""

    # Check for .env files
    mkdir -p "${service_full_path}"/conf
    for env_file in "${service_full_path}"/conf/*.env; do
        if [ -f "${env_file}" ]; then
            env_files_to_merge="${env_files_to_merge} ${env_file}"
        fi
    done

    # Check for global .env files
    mkdir -p "${SERVICES_PATH}"/conf
    save_arch_info
    save_defaults_info
    for env_file in "${SERVICES_PATH}"/conf/*.env; do
        if [ -f "${env_file}" ]; then
            env_files_to_merge="${env_files_to_merge} ${env_file}"
        fi
    done

    merge_env_files "${service_full_path}"/.env ${env_files_to_merge}

}

function set_text_editor() {
    local options=("vim" "nano" "vi" "emacs")
    if [ -f "${SCRIPT_PATH}/.text_editor" ]; then
        local selected_editor=$(cat "${SCRIPT_PATH}/.text_editor")
        if [[ " ${options[*]} " =~ ${selected_editor} ]] && [ -n "${selected_editor}" ]; then
            if command -v "${selected_editor}" &>/dev/null; then
                echo "${selected_editor}"
                return 0
            fi

        fi
    fi
    PS3="Select your preferred text editor: "
    select editor in "${options[@]}"; do
        if [[ " ${options[*]} " =~ ${editor} ]] ; then
            echo "$editor"
            echo "$editor" >"${SCRIPT_PATH}/.text_editor"
            return 0
        fi
        REPLY=
    done
}
function remove_comments_and_duplicates() {
    local file=$1
    sed -i.bkp -e '/^[ \t]*#/d' "${file}"
    rm "${file}.bkp"
    # This awk command reads the contents of the file specified by the variable 'file' and stores each line in an array 'a'.
    # It then prints the contents of the array in reverse order, removing any duplicate lines based on the first field (before the '=' character) using the 'seen' array.
    awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' "${file}" | awk -F= '!seen[$1]++' | awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' > "${file}.tmp"
    mv "${file}.tmp" "${file}"
}
function show() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    merge "${service}" >>/dev/null
    echo "Showing ${service}"
    cat "${service_full_path}/.env"
}

function config() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    if [ ! -f "${service_full_path}/config.sh" ]; then
        echo "No config.sh file found for ${service}"
        return
    fi
    "${service_full_path}"/config.sh
}

function start_example() {
    local example=$1
    if [ "$example" == "" ]; then
        echo "No example specified. Available Options:"
        find "${EXAMPLES_PATH}"/* -maxdepth 0 -type d -exec basename {} \; | awk '{print "  - "$0}'
        return
    fi
    local example_full_path="${EXAMPLES_PATH}/${example}"
    if [ ! -f "${example_full_path}/docker-compose.yml" ]; then
        echo "No docker-compose.yml file found for ${example}"
        return
    fi
    echo "Starting ${example}"
    cd "${example_full_path}" || exit 1
    ${DOCKER_COMPOSE} build
    ${DOCKER_COMPOSE} up -d
    sleep 1
    ${DOCKER_COMPOSE} ps
}

function deploy_example() {
    local example=$1
    if [ "$example" == "" ]; then
        echo "No example specified. Available Options:"
        find "${DEPLOYMENT_EXAMPLES_PATH}"/* -maxdepth 0 -type d -exec basename {} \;| awk '{print "  - "$0}'
        return
    fi
    local example_full_path="${DEPLOYMENT_EXAMPLES_PATH}/${example}"
    if [ ! -f "${example_full_path}/docker-compose.yml" ]; then
        echo "No docker-compose.yml file found for ${example}"
        return
    fi
    echo "Starting ${example}"
    cd "${example_full_path}" || exit 1
    if [ "$(uname -m)" == "aarch64" ]; then
        L4TBASE_VERSION=$(get_l4t_version)
        SIO_DOCKER_RUNTIME=nvidia SIO_DOCKER_TAG_VARIANT="-r${L4TBASE_VERSION}-arm64v8" ${DOCKER_COMPOSE} up -d
    else
        ${DOCKER_COMPOSE} up -d
    fi
    sleep 1
    ${DOCKER_COMPOSE} ps
}

function edit() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    merge "${service}" >>/dev/null
    echo "Editing ${service}"
    touch "${service_full_path}/conf/0001-edit.env"
    # Remove comments and duplicates from the edit file
    remove_comments_and_duplicates "${service_full_path}/conf/0001-edit.env"
    # Add Header
    cat <<EOF >"${service_full_path}/conf/0001-edit.env.tmp" 
# ATTENTION
#
# You are editing the ${service}/conf/0001-edit.env file
# In this file, you will find the uncommented lines corresponding to the current changes
# And below you will find commented lines corresponding to the current variables set on the .env file
#
# After you close this file, your changes will be stored at: "${service_full_path}/.env"
#
# Current changes:
EOF
    cat "${service_full_path}/conf/0001-edit.env" >> "${service_full_path}/conf/0001-edit.env.tmp"
    mv "${service_full_path}/conf/0001-edit.env.tmp" "${service_full_path}/conf/0001-edit.env"
    # Add the .env as commented lines to the edit
    cat <<EOF >>"${service_full_path}/conf/0001-edit.env"

# Uncomment any of these lines to apply:

EOF
    remove_comments_and_duplicates "${service_full_path}/.env"
    sed 's/^/# /' "${service_full_path}/.env" >>"${service_full_path}/conf/0001-edit.env"
    # Edit the edit file
    EDITOR=$(set_text_editor)
    if [ $? != 0 ]; then
        echo "Invalid editor selected: $EDITOR"
    fi
    set -e
    $EDITOR "${service_full_path}/conf/0001-edit.env"
    set +e
    merge "${service}" > /dev/null
    # Look for files ending in json or yml in conf
    for file in "${service_full_path}"/conf/*.{json,yml}; do
        if [ -f "${file}" ]; then
            read -rep "ATENTION: We found an extra configuration file for ${service}. Do you want to edit ${file}? (y/n) " answer
            if [[ $answer == [yY] ]]; then
                $EDITOR "${file}"
                echo
            else
                echo "Skipping edit\n"
            fi
        fi
    done
    set +e
}

function view() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    merge "${service}" >>/dev/null
    echo -e "\n${service_full_path}/.env:"
    cat "${service}/.env"
    # Look for files ending in json or yml in conf
    for file in "${service_full_path}"/conf/*.{json,yml}; do
        if [ -f "${file}" ]; then
        sleep 1
            echo -e "\n#########################################################"
            echo -e "${file}"
            echo -e "#########################################################\n"
            cat "${file}"
        fi
    done
}

function set_example () {
    local service=$1
    local example=$2
    local service_full_path="${SERVICES_PATH}/${service}"
    local examples_path="${service_full_path}/examples"
    echo "#" >> "${service_full_path}/conf/0001-edit.env"
    if [ -f "${service_full_path}/conf/0099-example.env" ]; then
        rm "${service_full_path}/conf/0099-example.env"
    fi
    for file in "${examples_path}/${example}"/*; do
        if [[ "$file" == *0001-edit.env ]]; then
            cat "$file" >> "${service_full_path}/conf/0001-edit.env"
        elif [[ ! "$file" == *.md ]]; then
            cp "$file" "${service_full_path}/conf"
        else
            cat "$file"
        fi
    done
    echo "#" >> "${service_full_path}/conf/0001-edit.env"
    echo "EXAMPLE=${example}" >> "${service_full_path}/conf/0001-edit.env"
    remove_comments_and_duplicates "${service_full_path}/conf/0001-edit.env"
    merge "${service}" >>/dev/null
    echo "Example set for ${service}: ${example}"
}

function select_example() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    local examples_path="${service_full_path}/examples"
    if [ -d "${examples_path}" ]; then
        local examples=($(ls "${examples_path}"))
        if [ ${#examples[@]} -eq 0 ]; then
            echo "No examples found in ${examples_path}"
            return 1
        fi
        if [ -n "$2" ]; then
            local example="$2"
            if [ -d "${examples_path}/${example}" ]; then
                set_example "${service}" "${example}"
                return 0
            else
                echo "Invalid example selected: ${example}"
                return 1
            fi
        else
            examples+=("Go back")
            PS3="Select an example or go back: "
            select example in "${examples[@]}"; do
                if [ "${example}" == "Go back" ]; then
                    return 0
                fi
                if [ -d "${examples_path}/${example}" ]; then
                    read -rep "Are you sure you want to use the ${example} example? (y/n) " answer
                    if [[ $answer == [yY] ]]; then
                        set_example "${service}" "${example}"
                        read -rep "Do you want to restart the ${service} service? (y/n) " restart_answer
                        if [[ $restart_answer == [yY] ]]; then
                           restart "${service}"
                        fi
                        return 0
                    fi
                else
                    echo "Invalid example selected: ${example}"
                fi
                REPLY=
            done
        fi
    else
        echo "No examples found in ${examples_path}"
        return 0
    fi
}


function create_network() {
    network_name=$1
    if [ "$(docker network ls | grep ${network_name})" == "" ]; then
        echo "Creating network ${network_name}"
        docker network create "${network_name}"
    fi
}

function create_default_networks() {
    create_network "sh-device-ui_sh-ui-net"
    create_network "core_sighthound"
}

function depends() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"

    # Check if the folder contains the "depends" file
    if [ -f "${service_full_path}/depends" ]; then
        # Read the contents of the "depends" file
        files=$(grep "file" "${service_full_path}"/depends | awk '{print $2}')
        # Loop through the files
        for file in $files; do
            echo "Checking file dependency: '$file'..."
            # Replace variables in the file string
            file=$(eval echo "$file")
            if [ -f "$file" ]; then
                # File is up, so print "service ready"
                echo "File '$file' is available."
            else
                echo "File is not available: '$file'. Stopping execution"
                return 1
            fi
        done

        # Read the contents of the "depends" file
        endpoints=$(grep "endpoint" "${service_full_path}"/depends | awk '{print $2}')

        # Loop through the endpoints
        for endpoint in $endpoints; do
            if [ -f "/proc/net/fib_trie" ]; then
                if [ -f /.dockerenv ]; then
                    # inside docker
                    gateway_ip=$(awk '/32 host/ { print i } {i=$2}' /proc/net/fib_trie | head -n 1 | awk -F'.' '{$NF="1"}1' OFS='.')
                else
                    gateway_ip=$(awk '/32 host/ { print i } {i=$2}' /proc/net/fib_trie | head -n 1)
                fi
                endpoint=${endpoint/gateway_ip/$gateway_ip}
            else
                endpoint=${endpoint/gateway_ip/localhost}
            fi
            up=0
            # Loop for 15 seconds or until the endpoint is up
            echo "Checking endpoint dependency: '$endpoint'..."
            for ((i = 0; i < 15; i++)); do
                if check_endpoint "$endpoint"; then
                    # Endpoint is up, so print "service ready"
                    echo "Endpoint '$endpoint' is ready"
                    up=1
                    break
                else
                    echo "Waiting for endpoint: '$endpoint' to be up..."
                    sleep 3
                fi
            done
            if [ $up -eq 0 ]; then
                # Endpoint was not up after 15 seconds, so stop the execution
                echo "Error: endpoint '$endpoint' was not up after 15 seconds"
                echo "Continuing execution."
            fi
        done

        enabled_services_up=$(grep "enabled_service_up" "${service_full_path}"/depends | awk '{print $2}')

        # Loop through the services
        for enabled_service in $enabled_services_up; do
            echo "Checking service dependency: '$enabled_service'..."
            if [ -f "${SERVICES_PATH}/${enabled_service}/disabled" ]; then
                echo "Service '$enabled_service' is disabled. Skipping"
            else
                up=0
                for ((i = 0; i < 5; i++)); do
                    if ! check_service_up "${enabled_service}"; then
                        echo "Waiting for service: '$enabled_service' to be up..."
                        sleep 3
                    else
                        up=1
                        break
                    fi
                done
                if [ $up -eq 0 ]; then
                    echo "Error: service '$enabled_service' was not up after 5 seconds"
                    echo "Continuing execution."
                fi
            fi
        done
    fi
    return 0
}

function start(){
    up "$@"
}

# Custom instructions for services
function pre_up() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    if [ "${service}" == "sio" ]; then
            # Select example if sio.json file is not found
            if [ ! -f "${service_full_path}/conf/${service}.json" ]; then
                echo "WARN: sio.json file not found: using the default one from the example"                           
                select_example "${service}" "default"                       
            fi     
            # Check .env for SIO_DOCKER_TAG
            local sio_docker_tag=$(grep 'SIO_DOCKER_TAG' "${service_full_path}/.env" | cut -d '=' -f2)
            local sh_arch=$(grep 'SH_ARCH' "${service_full_path}/.env" | cut -d '=' -f2)
            echo "SIO Docker tag from .env: ${sio_docker_tag}${sh_arch}"
    
            # Check if the SIO_DOCKER_TAG matches any stored Docker image tags
            local docker_images=$(docker images --format "{{.Repository}}:{{.Tag}} {{.ID}}" | grep '/sio:r2')
            if [ -z "$docker_images" ]; then
                echo "No sio images found. Skipping tag comparison and cleanup."
            else
                echo "Evaluating sio Docker images for tag $sio_docker_tag..."
                while IFS=' ' read -r img_full_tag img_id; do
                    if [[ -z "$img_id" || -z "$img_full_tag" ]]; then
                        echo "Skipping empty image entry..."
                        continue
                    fi
            
                    # Extract the tag for comparison
                    img_tag="${img_full_tag##*:}"
                    if [[ "$img_tag" == "$sio_docker_tag$sh_arch" ]]; then
                        echo "Found matching image $img_full_tag for sio"
                        tag_found=true
                    else
                        free_disk_space=$(df ${SH_BASE} | awk 'NR==2 {print $4}')
                        free_disk_space_human=$(df -h ${SH_BASE} | awk 'NR==2 {print $4}')
                        echo "Free disk space: $free_disk_space_human"
                        if [[ "$free_disk_space" < "3000000" ]]; then
                            size_human=$(docker image inspect --format='{{.Size}}' "$img_id" | numfmt --to=iec)
                            echo "Low disk space detected. Removing unmatched image $img_full_tag with ID $img_id for sio of size $size_human"
                            # Kill any  containers if they are running
                            docker ps -a | grep $img_full_tag | awk '{print $1}' | xargs -r docker rm -f
                            # Here, you would remove the image using its ID
                            docker rmi "$img_id" || echo "Failed to remove image ID $img_id"
                        else
                            echo "Skipping image $img_full_tag with ID $img_id, as there is enough disk space"
                        fi
                    fi
                done <<< "$docker_images"
            fi
    fi
}

function up() {
    local service=$1
    local background=$2
    local service_full_path="${SERVICES_PATH}/${service}"
    if [ ! -f "${service_full_path}/docker-compose.yml" ]; then
        echo "Service ${service} not found."
        return
    fi
    # Check if disabled file exists
    if [ -f "${service_full_path}/disabled" ]; then
        echo "Skipping ${service} : disabled file found"
        return
    fi

    echo "Bringing up ${service}"
    merge "${service}"

    pre_up "${service}"

    if [ -n "${background}" ] && [ "${background}" = "true" ]; then
        compose_up "${service}" &
        sleep 1
    else
        compose_up "${service}"
    fi    
}

function compose_up() {
    local service=$1
    if ! depends "${service}"; then
        echo "Skipping ${service} : depends failed"
        return
    fi
    cd "${SERVICES_PATH}/${service}" || exit 1
    echo "Starting ${service}"
    ${DOCKER_COMPOSE} up -d
    cd "${SERVICES_PATH}" || exit 1
}

function stop () {
    down "$@"
}

function down() {
    local service=$1
    echo "Stopping ${service}"
    cd "${SERVICES_PATH}/${service}" || exit 1
    ${DOCKER_COMPOSE} down
    cd "${SERVICES_PATH}" || exit 1
}

function restart() {
    local service=$1
    down "${service}"
    up "${service}"
}

function enable() {
    local service=$1
    if [ -f "${SERVICES_PATH}/${service}/disabled" ]; then
        echo "Enabling ${service}."
        rm "${SERVICES_PATH}/${service}/disabled"
    else
        echo "Service ${service} was already enabled."
    fi
}

function disable() {
    local service=$1
    if [ -f "${SERVICES_PATH}/${service}/disabled" ]; then
        echo "Skipping ${service} : disabled file found."
        return
    else
        echo "Disabling ${service}"
        touch "${SERVICES_PATH}/${service}/disabled"
    fi
    down "${service}"
}

function status() {
    local service=$1
    if [ -f "${SERVICES_PATH}/${service}/disabled" ]; then
        echo "disabled"
    else
        cd "${SERVICES_PATH}/${service}" || exit 1
        if ${DOCKER_COMPOSE} ps | grep -q "Up"; then
            echo "up"
        else
            echo "down"
        fi
        cd "${SERVICES_PATH}" || exit 1
    fi
}

function ps() {
    printf "%-20s %s\n" "SERVICE NAME" "STATUS"
    printf "%-20s %s\n" "------------" "------"
    for service_full_path in "${SERVICES_PATH}"/*; do
        if [ -d "${service_full_path}" ] && [ -f "${service_full_path}/docker-compose.yml" ]; then
            service_name=$(basename "${service_full_path}")
            if [ -f "${service_full_path}/disabled" ]; then
                printf "%-20s %s\n" "${service_name}" "disabled"
            else
                cd "${service_full_path}" || exit 1
                if ${DOCKER_COMPOSE} ps | grep -q "Up"; then
                    printf "%-20s %s\n" "${service_name}" "enabled (running)"
                else
                    printf "%-20s %s\n" "${service_name}" "enabled (not running)"
                fi
                cd "${SERVICES_PATH}" || exit 1
            fi
        fi
    done
}

function license() {
    if [ -f "${LICENSE_PATH}/sighthound-license.json" ]; then
        echo "License file found at  ${LICENSE_PATH}/sighthound-license.json:"
        cat "${LICENSE_PATH}/sighthound-license.json"
    else
        echo "No license file found"
        read -rep "Do you want to create a license file: ${LICENSE_PATH}/sighthound-license.json? (y/n)" answer
        if [[ $answer == [yY] ]]; then
            mkdir -p ${LICENSE_PATH}
            EDITOR=$(set_text_editor)
            ${EDITOR} "${LICENSE_PATH}/sighthound-license.json"
        fi
    fi
}

select_live555_video() {
  if [ -n "$1" ]; then
    file_path="$1"
  else
    read -u 0 -rep "Enter the path of an MKV file for the example live555 video:" file_path </dev/tty
  fi

  if [[ $file_path == *.mkv ]]; then
    if [ -f "$file_path" ]; then
      mkdir -p "${MEDIA_PATH}/input/video/live555"
      cp "$file_path" "${MEDIA_PATH}/input/video/live555/my-video.mkv"
      echo "Selected file: $file_path"
      ls -la "${MEDIA_PATH}"/input/video/live555/my-video.mkv
      return 0
    else
      echo "ERROR: Invalid file path or file does not exist: $file_path"
      return 1
    fi
  else
    if [[ $file_path == "" ]]; then
      echo "Contents of ${MEDIA_PATH}/input/video/live555:" 
      find "${MEDIA_PATH}/input/video/live555"
      echo "No file selected. Skipping...."
      sleep 3
      return 0
    else
      echo "Invalid file format. Please select a valid MKV file and try again."
      return 1
    fi
  fi
}

function element_in_list() {
    element=$1
    shift
    list=($@)
    for e in "${list[@]}"; do
        if [ "$e" == "$element" ]; then
            return 0
        fi
    done
    return 1
}

function interactively_handle_service() {
    local service=$1
    service_full_path="${SERVICES_PATH}/${service}"
    if [ -f "${service_full_path}/disabled" ]; then
        additional_text="(disabled)"
    else
        additional_text=""
    fi
    echo "Will ${command}: ${service}"
    echo "###############################################"
    echo "### ${service}" "${additional_text}"
    if [ -f "${service_full_path}/README.md" ]; then
        grep "short description" "${service_full_path}/README.md"
    fi
    echo "###############################################"

    command_capitalized="$(tr '[:lower:]' '[:upper:]' <<< ${command:0:1})${command:1}"
    options=("Edit service (.env)" "Enable example configuration" "Restart service" "Stop service" "Enable service" "Disable service" "View service configuration" "Go back")
    PS3='Please enter your choice: '
    select opt in "${options[@]}"; do
        if [[ "$REPLY" == "q" ]]; then
            break
        fi
        case $opt in
        "Go back")
            break
            ;;
        "Enable service")
            enable "${service}"
            break
            ;;
        "Restart service")
            enable "${service}"
            restart "${service}"
            break
            ;;
        "Stop service")
            stop "${service}"
            break
            ;;
        "Disable service")
            disable "${service}"
            break
            ;;
        "View service configuration")
            view "${service}"
            break
            ;;
        "Enable example configuration")
            select_example "${service}"
            break
            ;;
        "Edit service (.env)")
            edit "${service}"
            break
            ;;
        *)
            echo "Invalid option $REPLY" >&2
            ;;
        esac
        REPLY=
    done
}

function interactively_apply_command() {
    local command=$1
    shift 1
    local services=("$@")

    if [ ${#services[@]} -eq 1 ]; then
        interactively_handle_service "${services[0]}"
        return
    fi

    PS3='Please enter the service you want to edit: '
    select service in "${services[@]}" "Exit"; do
        if [ "$REPLY" == "q" ] ; then
            echo "Exiting..."
            break
        elif [ -n "$service" ]; then
            if [ "$service" == "Exit" ]; then
                echo "Exiting..."
                break
            fi
            interactively_handle_service "$service"
        else
            echo "Invalid option $REPLY"
        fi
        REPLY=
    done
}

function apply_to_services() {
    COMMAND=$1
    shift 1
    SERVICES=("$@")
    AVAILABLE_SERVICES_RAW=$(ls "${SERVICES_PATH}"/*/docker-compose.yml | sed -e 's/\/docker-compose.yml//g' -e 's/.*\///g')
    AVAILABLE_SERVICES=$(echo "${AVAILABLE_SERVICES_RAW}" | tr '\n' ' ')
    AVAILABLE_SERVICES="${AVAILABLE_SERVICES} all"
    # Check if services is empty
    if [ "${#SERVICES[@]}" -eq 0 ]; then
        echo "No services specified"
        echo "Usage: $0 $COMMAND <service1> <service2> ..."
        echo "Available services: ${AVAILABLE_SERVICES}"
        exit 1
    fi
    # Create networks
    create_default_networks

    # Check all services
    if element_in_list "all" "${SERVICES[@]}"; then
        echo "Applying command '${COMMAND}' to all services"
        SERVICES=(${AVAILABLE_SERVICES_RAW})
    fi

    case $COMMAND in
    "edit")
        interactively_apply_command "$COMMAND" "${SERVICES[@]}"
        ;;
    *)
        # Iterate services
        for service in "${SERVICES[@]}"; do
            # Check if service in AVAILABLE_SERVICES
            if element_in_list "${service}" "${AVAILABLE_SERVICES[@]}"; then
                if [[ "${service}" == " " ]]; then
                    continue
                fi
                if [[ ! -f "${SERVICES_PATH}/${service}/.env" ]]; then
                    merge "${service}"
                fi
                # Some commands should not print the service
                if [ "${COMMAND}" != "status" ] ; then
                    echo ""
                    echo "###############################################"
                    echo "### ${service}"
                    echo "###############################################"
                    echo "Applying command '${COMMAND}' to ${service}"
                fi
                # If services is an array of length > 1 then run in background, otherwise send false
                if [ "${#SERVICES[@]}" -gt 1 ]; then
                    ${COMMAND} "${service}" "true"
                else
                    ${COMMAND} "${service}" "false"
                fi
            else
                echo "Unknown service: ${service}"
                echo "Available services: ${AVAILABLE_SERVICES}"
            fi
        done
        if [ "${COMMAND}" == "restart" ] || [ "${COMMAND}" == "up" ] ; then
            echo "Waiting for services to finish: ${COMMAND}..."
        fi
        wait
        ;;
    esac
}

function apply() {
    filename=$1
    # Check if file exists
    if [ ! -f "$filename" ]; then
        echo "File not found: $filename"
        exit 1
    fi
    # Pre apply commands
    create_default_networks
    remove_orphans
    license
    # Apply commands
    set -e
    while IFS= read -r line || [[ -n "$line" ]]
    do
        echo "- $line"
        $line
        rt=$?
        if [ $rt -ne 0 ]; then
            echo "Error executing command: $line : $rt"
            exit 1
        fi
    done < "$filename"
    wait
    echo "Done"
}

LIST_OF_COMMANDS="    apply - Apply a configuration file
    merge - Combine several configuration files into a single .env file
    up [service(s)] - Starts docker-compose service
    down [service(s)] - Stops docker-compose service
    restart [service(s)] - Restarts docker-compose service
    show [service(s)] - Displays .env conf of a service
    status [service(s)] - Show the status of running service
    edit [service(s)] - Modify configurations or settings of a service
    config [service(s)] - Runs the configuration script of a service if available
    select_example [service(s)] - Select an example configuration for a service. E.g: select_example sio aqueduct
    start_example [example] - Start an example configuration. E.g: start_example AqueductAPI
    enable [service(s)] - Turn on a service
    disable [service(s)] - Turn off a service
    depends [service(s)] - Show the dependencies of a service and it's status
    license - Checks or creates the license file
    clean_media - Removes all media files and databases
    clean_logs - Empty the log files without deleting them
    remove_orphans - Remove containers for services not defined in the current configuration
    ps - List services and status
"

COMMAND=$1
shift 1 || true
case $COMMAND in
"select_example" | "set_example" | "select_live555_video" | "apply" | "test_rtsp_stream" | "start_example" | "deploy_example" )
    "$COMMAND" $@
    ;;
"merge" | "up" | "start" | "down" | "stop" | "restart" | "enable" | "disable" | "depends" | "edit" | "config" | "show" | "status")
    apply_to_services "$COMMAND" $@
    ;;
"clean_media" | "clean_logs" | "clean_rabbitmq" | "remove_orphans" | "check_rabbitmq"| "ps" | "license")
    "$COMMAND"
    ;;
"" | "help" | "-h" | "--help")
    echo -e "No command specified, choose one from the list: \n${LIST_OF_COMMANDS}"
    ;;
*)
    echo -e "Unknown command: ${COMMAND}, choose one from the list: \n${LIST_OF_COMMANDS}"
    ;;
esac
