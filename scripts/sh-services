#!/bin/bash
set -e
SCRIPT_PATH="$(
    cd -- "$(dirname "$0")" >/dev/null 2>&1
    pwd -P
)"
export SCRIPT_PATH
SH_BASE="$(realpath "${SCRIPT_PATH}"/../..)"
export SH_BASE
SERVICES_PATH="$(realpath "${SCRIPT_PATH}"/../services)"
export SERVICES_PATH
MEDIA_PATH="${SH_BASE}"/media
export MEDIA_PATH
DB_PATH="${SH_BASE}"/db
export DB_PATH
LOGS_PATH="${SH_BASE}"/logs
export LOGS_PATH
LICENSE_PATH="${SH_BASE}"/license
export LICENSE_PATH

# Check if curl is installed
if ! command -v curl &> /dev/null; then
    echo "curl is not installed. Please install curl and try again."
    exit 1
fi

if command -v docker-compose &>/dev/null && docker-compose version >/dev/null 2>&1; then
    # Use `docker-compose`
    DOCKER_COMPOSE="docker-compose"
elif command -v docker &>/dev/null && docker compose version >/dev/null 2>&1; then
    DOCKER_COMPOSE="docker compose"
else
    echo "Neither docker-compose nor docker compose are available. Please install one of them and try again."
    exit 1
fi

test_rtsp_stream() {
    local rtsp_url="$1"
    local timeout_seconds="$2"
    if ! command -v ffprobe &> /dev/null; then
        echo "FFmpeg is not installed. Please install FFmpeg first."
        return 1
    fi
    local status_code=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=codec_name -of default=nokey=1:noprint_wrappers=1 -rtsp_transport tcp "$rtsp_url" -timeout "$timeout_seconds" 2>/dev/null)

    if [[ -n $status_code ]]; then
        echo "RTSP stream $rtsp_url is up"
        return 0
    else
        echo "ERROR: RTSP stream $rtsp_url is down"
        return 1
    fi
}

check_endpoint() {
    curl --connect-timeout 2 --output /dev/null --silent --head $@ "$1"
}

check_service_up() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    local container_ids
    local container_id
    local state
    
    # Get container IDs
    container_ids=$(${DOCKER_COMPOSE} -f "${service_full_path}/docker-compose.yml" ps -a -q)
    
    # Check if there are no containers
    if [ -z "$container_ids" ]; then
        echo "No ${service} containers are found"
        return 1
    fi
    
    # Loop through each container ID
    for container_id in $container_ids; do
        # Get the state of the container
        state=$(docker inspect --format='{{.State.Status}}' "$container_id")
        
        # Check if the state is not 'running'
        if [ "$state" != "running" ]; then
            echo "Container '$container_id; from ${service} is not up"
            return 1
        fi
    done
    
    # If the function reaches this point, all containers are running
    echo "All ${service} containers are up"
    return 0
}

# Merge the services
# First file has the highest priority
# This function merges multiple environment files into a single output file
# The first argument is the output file name, and the rest are the input files
function merge_env_files() {
    output_file=$1
    shift 1
    env_files=$*

    echo "Merging ${env_files} into '${output_file}'"

    # Sort the input files and remove duplicates, then write the result to the output file
    set -e
    sort -u -t '=' -k 1,1 "$@" >"$1"
    set +e

    # Remove comments from the output file
    sed -i.bkp -e '/^[ \t]*#/d' "$1"
    rm "$1.bkp"

    echo ""
    echo "Resulting '${output_file}' file:"
    cat "$1"
    echo ""
}

function remove_orphans() {
    containers=$(docker ps -a -q)
    for container in $containers; do
        container_name=$(docker inspect -f '{{.Name}}' "${container}")
        working_dir=$(docker inspect -f '{{(index .Config.Labels "com.docker.compose.project.working_dir")}}' "${container}")
        if [[ "${working_dir}" == "${SH_BASE}"* ]]; then
            echo "Found container ${container_name} with working dir: '${working_dir}'"
            # If the working dir does not exist anymore and starts with 'SERVICES_PATH', then remove the container
            if [[ ! -d "${working_dir}" ]]; then
                echo "Removing orphan container: ${container_name} ${container}"
                docker rm -f "${container}"
            fi
        fi

    done
}

function clean_logs() {
    find "${LOGS_PATH:?}" -type f -exec truncate -s 0 {} \;
    echo "Removed all log files"
}

function clean_media() {
    echo "Cleaning media files"
    du -sh "${MEDIA_PATH:?}"
    # Remove all media files
    find "${MEDIA_PATH:?}" -type f -exec rm -f {} \;
    # Remove all timestamp subfolders as well
    find "${MEDIA_PATH:?}" -mindepth 4 -type d -exec rm -rf {} +
    # Remove all db files
    find "${DB_PATH:?}" -type f -exec rm -f {} \;
    # After removing db, restart mcp if it is running
    if [ "$(status mcp)" = "up" ]; then
        restart mcp
    fi
    echo "Removed all media files"
    du -sh "${MEDIA_PATH:?}"
}

function clean_rabbitmq() {
    down rabbitmq
    # Remove Docker volume if it exists
    if docker volume ls | grep -q "rabbitmq_rabbitmq_persistent_storage"; then
        echo "Removing rabbitmq_rabbitmq_persistent_storage volume"
        docker volume rm rabbitmq_rabbitmq_persistent_storage
    fi
    up rabbitmq
}

function save_defaults_info() {
    if [ ! -d "${SERVICES_PATH}"/conf ]; then
        mkdir -p "${SERVICES_PATH}"/conf
    fi
    cat <<EOF >"${SERVICES_PATH}"/conf/0020-services.env
# This file is autogenerated by the sh-services script
# Do not modify this file manually

SH_BASE=${SH_BASE}
SH_SERVICES_PATH=${SERVICES_PATH}
MEDIA_PATH=${MEDIA_PATH}
DB_PATH=${DB_PATH}
LOGS_PATH=${LOGS_PATH}
LICENSE_PATH=${LICENSE_PATH}
EOF
}

function save_arch_info() {
    if [ ! -d "${SERVICES_PATH}"/conf ]; then
        mkdir -p "${SERVICES_PATH}"/conf
    fi
    cat <<EOF >"${SERVICES_PATH}"/conf/0010-arch.env
# This file is autogenerated by the sh-services script
# Do not modify this file manually

EOF
    if [ "$(uname -m)" == "x86_64" ]; then
        echo "SH_ARCH=-amd64" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_NODE=false" >>"${SERVICES_PATH}"/conf/0010-arch.env
    elif [ "$(uname -m)" == "aarch64" ]; then
        L4TBASE_VERSION=32.7.3
        if command -v bai-osinfo &>/dev/null; then
            L4TBASE_VERSION=$(bai-osinfo -l)
            [[ "$L4TBASE_VERSION" == 32.7.* ]] && L4TBASE_VERSION=32.7.3
            SH_MACHINE=$(bai-osinfo -m)
            SH_SERIAL=$(bai-osinfo -s)
            if [[ $SH_MACHINE == *"node"* ]]; then
                SH_NODE=true
            else
                SH_NODE=false
            fi
        fi
        
        echo "SH_ARCH=-r${L4TBASE_VERSION}-arm64v8" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_MACHINE=${SH_MACHINE}" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_NODE=${SH_NODE}" >>"${SERVICES_PATH}"/conf/0010-arch.env
        echo "SH_SERIAL=${SH_SERIAL}" >>"${SERVICES_PATH}"/conf/0010-arch.env
        # TODO: remove this hardcoded env var
        if [[ $SH_NODE == "false" ]]; then
            echo "SIO_ENABLE_NVMPI=0" >>"${SERVICES_PATH}"/conf/0010-arch.env
        fi
    else
        echo "Unknown architecture: $(uname -m)"
        exit 1
    fi
}

function merge() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    touch "${service_full_path}/.env"
    env_files_to_merge="${service_full_path}/.env"

    # Check for .env files
    mkdir -p "${service_full_path}"/conf
    for env_file in "${service_full_path}"/conf/*.env; do
        if [ -f "${env_file}" ]; then
            env_files_to_merge="${env_files_to_merge} ${env_file}"
        fi
    done

    # Check for global .env filesmerge_env_files
    mkdir -p "${SERVICES_PATH}"/conf
    save_arch_info
    save_defaults_info
    for env_file in "${SERVICES_PATH}"/conf/*.env; do
        if [ -f "${env_file}" ]; then
            env_files_to_merge="${env_files_to_merge} ${env_file}"
        fi
    done

    merge_env_files "${service_full_path}"/.env ${env_files_to_merge}

}

function set_text_editor() {
    local options=("vim" "nano" "vi" "emacs")
    if [ -f "${SCRIPT_PATH}/.text_editor" ]; then
        local selected_editor=$(cat "${SCRIPT_PATH}/.text_editor")
        if [[ " ${options[*]} " =~ ${selected_editor} ]] && [ -n "${selected_editor}" ]; then
            if command -v "${selected_editor}" &>/dev/null; then
                echo "${selected_editor}"
                return 0
            fi

        fi
    fi
    PS3="Select your preferred text editor: "
    select editor in "${options[@]}"; do
        if [[ " ${options[*]} " =~ ${editor} ]] ; then
            echo "$editor"
            echo "$editor" >"${SCRIPT_PATH}/.text_editor"
            return 0
        fi
        REPLY=
    done    
}
function remove_comments_and_duplicates() {
    local file=$1
    sed -i.bkp -e '/^[ \t]*#/d' "${file}"
    rm "${file}.bkp"
    # This awk command reads the contents of the file specified by the variable 'file' and stores each line in an array 'a'.
    # It then prints the contents of the array in reverse order, removing any duplicate lines based on the first field (before the '=' character) using the 'seen' array.
    awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' "${file}" | awk -F= '!seen[$1]++' | awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' > "${file}.tmp" 
    mv "${file}.tmp" "${file}"
}
function show() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    merge "${service}" >>/dev/null
    echo "Showing ${service}"
    cat "${service_full_path}/.env"
}

function config() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    if [ ! -f "${service_full_path}/config.sh" ]; then
        echo "No config.sh file found for ${service}"
        return
    fi
    "${service_full_path}"/config.sh
}

function edit() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    merge "${service}" >>/dev/null
    echo "Editing ${service}"
    touch "${service_full_path}/conf/0001-edit.env"
    # Remove comments and duplicates from the edit file
    remove_comments_and_duplicates "${service}/conf/0001-edit.env"
    # Add the .env as commented lines to the edit
    sed 's/^/# /' "${service_full_path}/.env" >>"${service_full_path}/conf/0001-edit.env"
    # Edit the edit file
    EDITOR=$(set_text_editor)
    if [ $? != 0 ]; then
        echo "Invalid editor selected: $EDITOR"
    fi
    read -rep "Do you want to edit the main configuration: ${service_full_path}/conf/0001-edit.env? (y/n)" answer
            if [[ $answer == [yY] ]]; then
                set -e
                $EDITOR "${service_full_path}/conf/0001-edit.env"
                set +e
                echo -e "Contents from ${service_full_path}/conf/0001-edit.env were merged with the default values, the outcome is stored at ${service_full_path}/.env (used by docker-compose)"
            fi
    merge "${service}" > /dev/null
    # Look for files ending in json or yml in conf
    for file in "${service_full_path}"/conf/*.{json,yml}; do
        if [ -f "${file}" ]; then
            read -rep "Do you want to edit ${file}? (y/n) " answer
            if [[ $answer == [yY] ]]; then
                $EDITOR "${file}"
            fi
        fi
    done
    set +e
}

function view() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    merge "${service}" >>/dev/null
    echo -e "\n${service_full_path}/.env:"
    cat "${service}/.env"
    # Look for files ending in json or yml in conf
    for file in "${service_full_path}"/conf/*.{json,yml}; do
        if [ -f "${file}" ]; then
        sleep 1
            echo -e "\n#########################################################"
            echo -e "${file}"
            echo -e "#########################################################\n"
            cat "${file}"
        fi
    done
}

function set_example () {
    local service=$1
    local example=$2
    local service_full_path="${SERVICES_PATH}/${service}"
    local examples_path="${service_full_path}/examples"
    echo "#" >> "${service_full_path}/conf/0001-edit.env"
    if [ -f "${service_full_path}/conf/0099-example.env" ]; then
        rm "${service_full_path}/conf/0099-example.env"
    fi
    for file in "${examples_path}/${example}"/*; do
        if [[ "$file" == *0001-edit.env ]]; then
            cat "$file" >> "${service_full_path}/conf/0001-edit.env"
        elif [[ ! "$file" == *.md ]]; then
            cp "$file" "${service_full_path}/conf"
        else
            cat "$file"
        fi
    done
    echo "#" >> "${service_full_path}/conf/0001-edit.env"
    echo "EXAMPLE=${example}" >> "${service_full_path}/conf/0001-edit.env"
    remove_comments_and_duplicates "${service_full_path}/conf/0001-edit.env"
    merge "${service}" >>/dev/null
    echo "Example set for ${service}: ${example}"
}

function select_example() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    local examples_path="${service_full_path}/examples"
    if [ -d "${examples_path}" ]; then
        local examples=($(ls "${examples_path}"))
        if [ ${#examples[@]} -eq 0 ]; then
            echo "No examples found in ${examples_path}"
            return 1
        fi
        if [ -n "$2" ]; then
            local example="$2"
            if [ -d "${examples_path}/${example}" ]; then
                set_example "${service}" "${example}"
                return 0
            else
                echo "Invalid example selected: ${example}"
                return 1
            fi
        else
            examples+=("Go back")
            PS3="Select an example or go back: "
            select example in "${examples[@]}"; do
                if [ "${example}" == "Go back" ]; then
                    return 0
                fi
                if [ -d "${examples_path}/${example}" ]; then
                    read -rep "Are you sure you want to use the ${example} example? (y/n) " answer
                    if [[ $answer == [yY] ]]; then
                        set_example "${service}" "${example}"
                        read -rep "Do you want to restart the ${service} service? (y/n) " restart_answer
                        if [[ $restart_answer == [yY] ]]; then
                           restart "${service}"
                        fi
                        return 0
                    fi
                else
                    echo "Invalid example selected: ${example}"
                fi
                REPLY=
            done
        fi
    else
        echo "No examples found in ${examples_path}"
        return 0
    fi
}


function create_network() {
    network_name=$1
    if [ "$(docker network ls | grep ${network_name})" == "" ]; then
        echo "Creating network ${network_name}"
        docker network create "${network_name}"
    fi
}

function depends() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    
    # Check if the folder contains the "depends" file
    if [ -f "${service_full_path}/depends" ]; then
        # Read the contents of the "depends" file
        files=$(grep "file" "${service_full_path}"/depends | awk '{print $2}')
        # Loop through the files
        for file in $files; do
            echo "Checking file dependency: '$file'..."
            # Replace variables in the file string
            file=$(eval echo "$file")
            if [ -f "$file" ]; then
                # File is up, so print "service ready"
                echo "File '$file' is available."
            else
                echo "File is not available: '$file'. Stopping execution"
                return 1
            fi
        done

        # Read the contents of the "depends" file
        endpoints=$(grep "endpoint" "${service_full_path}"/depends | awk '{print $2}')

        # Loop through the endpoints
        for endpoint in $endpoints; do
            if [ -f "/proc/net/fib_trie" ]; then
                if [ -f /.dockerenv ]; then
                    # inside docker
                    gateway_ip=$(awk '/32 host/ { print i } {i=$2}' /proc/net/fib_trie | head -n 1 | awk -F'.' '{$NF="1"}1' OFS='.')
                else
                    gateway_ip=$(awk '/32 host/ { print i } {i=$2}' /proc/net/fib_trie | head -n 1)
                fi
                endpoint=${endpoint/gateway_ip/$gateway_ip}
            else
                endpoint=${endpoint/gateway_ip/localhost}
            fi
            up=0
            # Loop for 15 seconds or until the endpoint is up
            echo "Checking endpoint dependency: '$endpoint'..."
            for ((i = 0; i < 15; i++)); do
                if check_endpoint "$endpoint"; then
                    # Endpoint is up, so print "service ready"
                    echo "Endpoint '$endpoint' is ready"
                    up=1
                    break
                else
                    echo "Waiting for endpoint: '$endpoint' to be up..."
                    sleep 3
                fi
            done
            if [ $up -eq 0 ]; then
                # Endpoint was not up after 15 seconds, so stop the execution
                echo "Error: endpoint '$endpoint' was not up after 15 seconds"
                echo "Continuing execution."
            fi
        done

        enabled_services_up=$(grep "enabled_service_up" "${service_full_path}"/depends | awk '{print $2}')

        # Loop through the services
        for enabled_service in $enabled_services_up; do
            echo "Checking service dependency: '$enabled_service'..."
            if [ -f "${SERVICES_PATH}/${enabled_service}/disabled" ]; then
                echo "Service '$enabled_service' is disabled. Skipping"
            else
                up=0
                for ((i = 0; i < 5; i++)); do
                    if ! check_service_up "${enabled_service}"; then
                        echo "Waiting for service: '$enabled_service' to be up..."
                        sleep 3
                    else
                        up=1
                        break
                    fi
                done
                if [ $up -eq 0 ]; then
                    echo "Error: service '$enabled_service' was not up after 5 seconds"
                    echo "Continuing execution."
                fi
            fi
        done
    fi
    return 0
}

function up() {
    local service=$1
    local service_full_path="${SERVICES_PATH}/${service}"
    if [ ! -f "${service_full_path}/docker-compose.yml" ]; then
        echo "Service ${service} not found."
        return
    fi
    # Check if disabled file exists
    if [ -f "${service_full_path}/disabled" ]; then
        echo "Skipping ${service} : disabled file found"
        return
    fi
    echo "Bringing up ${service}"
    merge "${service}"
    compose_up "${service}" &
    sleep 1
}

function compose_up() {
    local service=$1
    if ! depends "${service}"; then
        echo "Skipping ${service} : depends failed"
        return
    fi
    cd "${SERVICES_PATH}/${service}" || exit 1
    echo "Starting ${service}"
    ${DOCKER_COMPOSE} up -d
    cd "${SERVICES_PATH}" || exit 1
}

function down() {
    local service=$1
    echo "Stopping ${service}"
    cd "${SERVICES_PATH}/${service}" || exit 1
    ${DOCKER_COMPOSE} down
    cd "${SERVICES_PATH}" || exit 1
}

function restart() {
    local service=$1
    down "${service}"
    up "${service}"
}

function enable() {
    local service=$1
    if [ -f "${SERVICES_PATH}/${service}/disabled" ]; then
        echo "Enabling ${service}."
        rm "${SERVICES_PATH}/${service}/disabled"
    else
        echo "Service ${service} was already enabled."
    fi
}

function disable() {
    local service=$1
    if [ -f "${SERVICES_PATH}/${service}/disabled" ]; then
        echo "Skipping ${service} : disabled file found."
        return
    else
        echo "Disabling ${service}"
        touch "${SERVICES_PATH}/${service}/disabled"
    fi
    down "${service}"
}

function status() {
    local service=$1
    if [ -f "${SERVICES_PATH}/${service}/disabled" ]; then
        echo "disabled"
    else
        cd "${SERVICES_PATH}/${service}" || exit 1
        if ${DOCKER_COMPOSE} ps | grep -q "Up"; then
            echo "up"
        else
            echo "down"
        fi
        cd "${SERVICES_PATH}" || exit 1
    fi
}

function ps() {
    printf "%-20s %s\n" "SERVICE NAME" "STATUS"
    printf "%-20s %s\n" "------------" "------"
    for service_full_path in "${SERVICES_PATH}"/*; do
        if [ -d "${service_full_path}" ] && [ -f "${service_full_path}/docker-compose.yml" ]; then
            service_name=$(basename "${service_full_path}")
            if [ -f "${service_full_path}/disabled" ]; then
                printf "%-20s %s\n" "${service_name}" "disabled"
            else
                cd "${service_full_path}" || exit 1
                if ${DOCKER_COMPOSE} ps | grep -q "Up"; then
                    printf "%-20s %s\n" "${service_name}" "enabled (running)"
                else
                    printf "%-20s %s\n" "${service_name}" "enabled (not running)"
                fi
                cd "${SERVICES_PATH}" || exit 1
            fi
        fi
    done
}

function license() {
    if [ -f "${LICENSE_PATH}/sighthound-license.json" ]; then
        echo "License file found at  ${LICENSE_PATH}/sighthound-license.json:"
        cat "${LICENSE_PATH}/sighthound-license.json"
    else
        echo "No license file found"
        read -rep "Do you want to create alicense file: ${LICENSE_PATH}/sighthound-license.json? (y/n)" answer
        if [[ $answer == [yY] ]]; then
            EDITOR=$(set_text_editor)
            ${EDITOR} "${LICENSE_PATH}/sighthound-license.json"
        fi
    fi
}

select_live555_video() {
  if [ -n "$1" ]; then
    file_path="$1"
  else
    read -u 0 -rep "Enter the path of an MKV file for the example live555 video:" file_path </dev/tty
  fi

  if [[ $file_path == *.mkv ]]; then
    if [ -f "$file_path" ]; then
      mkdir -p "${SERVICES_PATH}/live555/test-data"
      cp "$file_path" "${SERVICES_PATH}/live555/test-data/my-video.mkv"
      echo "Selected file: $file_path"
    else
      echo "Invalid file path or file does not exist: $file_path"
    fi
  else
    echo "Invalid file format. Please select an MKV file."
  fi
}

function element_in_list() {
    element=$1
    shift
    list=($@)
    for e in "${list[@]}"; do
        if [ "$e" == "$element" ]; then
            return 0
        fi
    done
    return 1
}

function interactively_handle_service() {
    local service=$1
    service_full_path="${SERVICES_PATH}/${service}"
    if [ -f "${service_full_path}/disabled" ]; then
        additional_text="(disabled)"
    else
        additional_text=""
    fi
    echo "Will ${command}: ${service}"
    echo "###############################################"
    echo "### ${service}" "${additional_text}"
    if [ -f "${service_full_path}/README.md" ]; then
        grep "short description" "${service_full_path}/README.md"
    fi
    echo "###############################################"

    command_capitalized="$(tr '[:lower:]' '[:upper:]' <<< ${command:0:1})${command:1}"
    options=("$command_capitalized service" "Enable example configuration" "Restart service" "Stop service" "Enable service" "Disable service" "View service configuration" "Go back")
    PS3='Please enter your choice: '
    select opt in "${options[@]}"; do
        if [[ "$REPLY" == "q" ]]; then
            break
        fi
        case $opt in
        "Go back")
            break
            ;;
        "Enable service")
            enable "${service}"
            break
            ;;
        "Restart service")
            enable "${service}"
            restart "${service}"
            break
            ;;
        "Stop service")
            stop "${service}"
            break
            ;;
        "Disable service")
            disable "${service}"
            break
            ;;
        "View service configuration")
            view "${service}"
            break
            ;;
        "Enable example configuration")
            select_example "${service}"
            break
            ;;
        "$command_capitalized service")
            $command "${service}"
            break
            ;;
        *)
            echo "Invalid option $REPLY" >&2
            ;;
        esac
        REPLY=
    done
}

function interactively_apply_command() {
    local command=$1
    shift 1
    local services=("$@")

    if [ ${#services[@]} -eq 1 ]; then
        interactively_handle_service "${services[0]}"
        return
    fi

    PS3='Please enter the service you want to edit: '
    select service in "${services[@]}" "Exit"; do
        if [ "$REPLY" == "q" ] ; then
            echo "Exiting..."
            break
        elif [ -n "$service" ]; then
            if [ "$service" == "Exit" ]; then
                echo "Exiting..."
                break
            fi
            interactively_handle_service "$service"
        else 
            echo "Invalid option $REPLY"
        fi
        REPLY=
    done
}

function apply_to_services() {
    COMMAND=$1
    shift 1
    SERVICES=("$@")
    AVAILABLE_SERVICES_RAW=$(ls "${SERVICES_PATH}"/*/docker-compose.yml | sed -e 's/\/docker-compose.yml//g' -e 's/.*\///g')
    AVAILABLE_SERVICES=$(echo "${AVAILABLE_SERVICES_RAW}" | tr '\n' ' ')
    AVAILABLE_SERVICES="${AVAILABLE_SERVICES} all"
    # Check if services is empty
    if [ "${#SERVICES[@]}" -eq 0 ]; then
        echo "No services specified"
        echo "Usage: $0 $COMMAND <service1> <service2> ..."
        echo "Available services: ${AVAILABLE_SERVICES}"
        exit 1
    fi
    # Create networks
    create_network "sh-device-ui_sh-ui-net"
    create_network "core_sighthound"

    # Check all services
    if element_in_list "all" "${SERVICES[@]}"; then
        echo "Applying command '${COMMAND}' to all services"
        SERVICES=(${AVAILABLE_SERVICES_RAW})
    fi

    case $COMMAND in
    "edit")
        interactively_apply_command "$COMMAND" "${SERVICES[@]}"
        ;;
    *)
        # Iterate services
        for service in "${SERVICES[@]}"; do
            # Check if service in AVAILABLE_SERVICES
            if element_in_list "${service}" "${AVAILABLE_SERVICES[@]}"; then
                if [ "${service}" == " " ]; then
                    continue
                fi
                # Some commands should not print the service
                if [ "${COMMAND}" != "status" ] ; then
                    echo ""
                    echo "###############################################"
                    echo "### ${service}"
                    echo "###############################################"
                    echo "Applying command '${COMMAND}' to ${service}"
                fi
                $COMMAND "${service}"
            else
                echo "Unknown service: ${service}"
                echo "Available services: ${AVAILABLE_SERVICES}"
            fi
        done
        if [ "${COMMAND}" == "restart" ] || [ "${COMMAND}" == "up" ] || [ "${COMMAND}" == "down" ]; then
            echo "Waiting for services to finish: ${COMMAND}..."
        fi
        wait
        ;;
    esac
}

function apply() {
    filename=$1
    # Check if file exists
    if [ ! -f "$filename" ]; then
        echo "File not found: $filename"
        exit 1
    fi
    while IFS= read -r line || [[ -n "$line" ]]
    do
        echo "- $line"
        $line
    done < "$filename"
    wait
    echo "Done"
}

LIST_OF_COMMANDS="    apply - Apply a configuration file
    merge - Combine several configuration files into a single .env file
    up [service(s)] - Starts docker-compose service
    down [service(s)] - Stops docker-compose service
    restart [service(s)] - Restarts docker-compose service
    show [service(s)] - Displays .env conf of a service
    status [service(s)] - Show the status of running service
    edit [service(s)] - Modify configurations or settings of a service
    config [service(s)] - Runs the configuration script of a service if available
    select_example [service(s)] - Select an example configuration for a service. E.g: select_example sio aqueduct
    enable [service(s)] - Turn on a service
    disable [service(s)] - Turn off a service
    depends [service(s)] - Show the dependencies of a service and it's status
    license - Checks or creates the license file
    clean_media - Removes all media files and databases
    clean_logs - Empty the log files without deleting them
    remove_orphans - Remove containers for services not defined in the current configuration
    ps - List services and status
"

COMMAND=$1
shift 1 || true
case $COMMAND in
"select_example" | "select_live555_video" | "apply" | "test_rtsp_stream")
    "$COMMAND" $@
    ;;
"merge" | "up" | "down" | "restart" | "enable" | "disable" | "depends" | "edit" | "config" | "show" | "status")
    apply_to_services "$COMMAND" $@
    ;;
"clean_media" | "clean_logs" | "clean_rabbitmq" | "remove_orphans" | "ps" | "license")
    "$COMMAND"
    ;;
"" | "help" | "-h" | "--help")
    echo -e "No command specified, choose one from the list: \n${LIST_OF_COMMANDS}"
    ;;
*)
    echo -e "Unknown command: ${COMMAND}, choose one from the list: \n${LIST_OF_COMMANDS}"
    ;;
esac
